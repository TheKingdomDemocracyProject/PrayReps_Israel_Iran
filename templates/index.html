<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Praying for elected representatives around the world</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <h1 class="main-title">Praying for elected representatives around the world</h1>
    <div class="queue-info">
        <div>Representatives left to pray for: <span id="remaining">{{ remaining }}</span></div>
        <div>Representatives waiting for prayer: <span id="queue_size">{{ queue|length }}</span></div>
    </div>
    <div class="content">
        <div class="left-content">
            <div id="current-constituency" class="sentence-box">
                Waiting for results. Stay tuned!
            </div>
            <div class="controls">
                <button id="next-button" onclick="nextConstituency()" style="display: none;">Amen üôè</button>
            </div>
        </div>
        <div class="right-content">
            <img id="hex-map" src="{{ url_for('static', filename='hex_map.png') }}" alt="Hex Map" class="hex-map">
        </div>
    </div>
    <ul id="queue_list"></ul>
    <div class="links">
        {# Ensure default_country_code is available, or fallback to the first key from all_countries if COUNTRIES_CONFIG is not empty #}
        {# {% set display_country_code = default_country_code if default_country_code else (list(all_countries.keys())[0] if all_countries else None) %} #}

        {# Always show overall links, and specific country links if a default is available #}
        <a href="{{ url_for('prayed_list_overall') }}">View prayed for representatives</a>
        <a href="{{ url_for('statistics_overall') }}">View Statistics</a>
        <a href="{{ url_for('queue_page') }}">View Full Queue</a>
    </div>
    <script>
        const allCountriesConfig = {{ all_countries | tojson }};
        let processedCount = {{ (all_countries.values() | sum(attribute='total_representatives')) - remaining }}; // Calculate initial prayed based on total from all countries
        const totalRepresentativesAllCountries = {{ (all_countries.values() | sum(attribute='total_representatives')) }};
        let currently_displayed_map_country_code = {{ initial_map_country_code | tojson }};


        function updateQueueInfo() {
            console.log('Fetching queue data...');
            fetch('/queue/json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && Array.isArray(data)) {
                        console.log('Queue data:', data);
                        document.getElementById('queue_size').innerText = data.length;
                        if (data.length > 0) {
                            const current = data[0];
                            const new_person_country_code = current.country_code; // Use a distinct name for clarity
                            const countryName = (allCountriesConfig && allCountriesConfig[new_person_country_code]) ? allCountriesConfig[new_person_country_code].name : 'Unknown Country';

                            let representativeText = '';
                            if (!current.place || current.place === 'N/A' || current.place.trim() === '') {
                                representativeText = `Praying for <span id="personName">${current.person_name}</span> who serves ${countryName}`;
                            } else {
                                representativeText = `Praying for <span id="personName">${current.person_name}</span> from ${countryName} representing <span id="constituency">${current.place}</span>`;
                            }

                            document.getElementById('current-constituency').innerHTML = `
                                <div class="profile">
                                    <div class="profile-image-container">
                                        <img id="profileImage" src="${current.thumbnail}" alt="Profile image of ${current.person_name}">
                                    </div>
                                    <div class="profile-text">
                                        ${representativeText}
                                    </div>
                                </div>
                            `;

                            if (new_person_country_code && new_person_country_code !== currently_displayed_map_country_code) {
                                console.log(`Current person's country (${new_person_country_code}) differs from displayed map (${currently_displayed_map_country_code}). Fetching new map.`);
                                fetch(`/generate_map_for_country/${new_person_country_code}`)
                                    .then(response => {
                                        if (!response.ok) {
                                            throw new Error(`Failed to generate map for ${new_person_country_code}: ${response.statusText}`);
                                        }
                                        return response.json();
                                    })
                                    .then(map_gen_response => {
                                        console.log(map_gen_response.status || 'Map generation triggered.');
                                        currently_displayed_map_country_code = new_person_country_code; // Update current map country
                                        reloadHexMap(); // Reload the map image since the country changed
                                    })
                                    .catch(error => {
                                        console.error('Error updating map for new country:', error);
                                    });
                            }
                            // NO reloadHexMap() here anymore if country is the same during polling
                            document.getElementById('next-button').style.display = 'block';
                        } else {
                            document.getElementById('current-constituency').innerText = 'All prayers complete or queue is empty. Stay tuned!';
                            document.getElementById('next-button').style.display = 'none';
                            // NO reloadHexMap() here anymore if queue is empty during polling
                        }
                    } else {
                        console.error('Unexpected data format:', data);
                    }
                })
                .catch(error => {
                    console.error('There has been a problem with your fetch operation:', error);
                });
        }

        function reloadHexMap() {
            const hexMap = document.getElementById('hex-map');
            const newSrc = hexMap.src.split('?')[0] + '?' + new Date().getTime();  // Force reload by adding a timestamp
            // ==== DETAILED LOGGING START ====
            console.log("Reloading hex map with new source:", newSrc);
            // ==== DETAILED LOGGING END ====
            const newImage = new Image();
            newImage.onload = function () {
                hexMap.src = newSrc;
            }
            newImage.src = newSrc;
        }

        function nextConstituency() {
            fetch('/process_item', { method: 'POST' })
                .then(response => { // Added response parameter to check if needed, though original didn't use it
                    if (!response.ok) { // Basic error check for the POST itself
                        console.error('Process item request failed:', response.statusText);
                        // Optionally update UI to indicate failure or retry
                        return; // Stop further processing in this chain
                    }
                    processedCount++;
                    const remainingElement = document.getElementById('remaining');
                    let currentRemaining = parseInt(remainingElement.innerText);
                    if (!isNaN(currentRemaining)) {
                        remainingElement.innerText = Math.max(0, currentRemaining - 1);
                    }

                    // Fetch and log the next item from /queue/json
                    fetch('/queue/json')
                        .then(response => response.json())
                        .then(data => {
                            if (data && Array.isArray(data) && data.length > 0) {
                                console.log('Next item from queue/json after process_item:', data[0]);
                            } else if (data && Array.isArray(data) && data.length === 0) {
                                console.log('Queue is empty after process_item.');
                            } else {
                                console.log('Unexpected data format from queue/json after process_item:', data);
                            }
                            updateQueueInfo(); // Call updateQueueInfo to refresh UI text and potentially country map
                            reloadHexMap();   // Explicitly reload map image as /process_item updated it
                        })
                        .catch(error => {
                            console.error('Error fetching queue/json after processing item:', error);
                            updateQueueInfo(); // Still call updateQueueInfo to refresh UI
                            reloadHexMap();   // Still reload map as /process_item likely succeeded
                        });
                })
                .catch(error => {
                    console.error('Error processing item:', error);
                });
        }

        function purgeQueue() {
            fetch('/purge', { method: 'POST' }) // Assuming GET for purge as per app.py, if POST, keep as is.
                                                // The instruction for app.py had /purge as GET.
                .then(response => {
                    if(response.ok) {
                        // Update UI after successful purge
                        processedCount = 0;
                        document.getElementById('remaining').innerText = totalRepresentativesAllCountries; // Reset to total
                        updateQueueInfo(); // This will refresh the queue display (should be empty)
                                           // and current-constituency message.
                    } else {
                        console.error('Purge request failed');
                    }
                })
                .catch(error => {
                    console.error('Error purging queue:', error);
                });
        }

        setInterval(updateQueueInfo, 10000);  // Update every 10 seconds
        updateQueueInfo();  // Initial call to populate the data immediately
    </script>
</body>
</html>
