<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Praying for elected representatives around the world</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <h1 class="main-title">Praying for elected representatives around the world</h1>
    <div class="queue-info">
        <div>Representatives left to pray for: <span id="remaining">{{ remaining }}</span></div>
        <div>Representatives waiting for prayer: <span id="queue_size">{{ queue|length }}</span></div>
    </div>
    <div class="content">
        <div class="left-content">
            <div id="current-constituency" class="sentence-box">
                Waiting for results. Stay tuned!
            </div>
            <div class="controls">
                <button id="next-button" onclick="nextConstituency()" style="display: none;">Amen üôè</button>
            </div>
        </div>
        <div class="right-content">
            <img id="hex-map" src="{{ url_for('static', filename='hex_map.png') }}" alt="Hex Map" class="hex-map">
        </div>
    </div>
    <ul id="queue_list"></ul>
    <div class="links">
        {# Ensure default_country_code is available, or fallback to the first key from all_countries if COUNTRIES_CONFIG is not empty #}
        {# {% set display_country_code = default_country_code if default_country_code else (list(all_countries.keys())[0] if all_countries else None) %} #}

        {# Always show overall links, and specific country links if a default is available #}
        <a href="{{ url_for('prayed_list_overall') }}">View prayed for representatives</a>
        <a href="{{ url_for('statistics_overall') }}">View Statistics</a>
        <a href="{{ url_for('queue_page') }}">View Full Queue</a>
    </div>
    <script>
        const allCountriesConfig = {{ all_countries | tojson }};
        let processedCount = {{ (all_countries.values() | sum(attribute='total_representatives')) - remaining }}; // Calculate initial prayed based on total from all countries
        const totalRepresentativesAllCountries = {{ (all_countries.values() | sum(attribute='total_representatives')) }};
        let currently_displayed_map_country_code = {{ initial_map_country_code | tojson }};


        function updateQueueInfo() {
            console.log('Fetching queue data...');
            fetch('/queue/json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && Array.isArray(data)) {
                        console.log('Queue data:', data);
                        document.getElementById('queue_size').innerText = data.length;
                        if (data.length > 0) {
                            const current = data[0];
                            const new_person_country_code = current.country_code; // Use a distinct name for clarity
                            const countryName = (allCountriesConfig && allCountriesConfig[new_person_country_code]) ? allCountriesConfig[new_person_country_code].name : 'Unknown Country';

                            let representativeText = '';
                            if (!current.place || current.place === 'N/A' || current.place.trim() === '') {
                                representativeText = `Praying for <span id="personName">${current.person_name}</span> who serves ${countryName}`;
                            } else {
                                representativeText = `Praying for <span id="personName">${current.person_name}</span> from ${countryName} representing <span id="constituency">${current.place}</span>`;
                            }

                            document.getElementById('current-constituency').innerHTML = `
                                <div class="profile">
                                    <div class="profile-image-container">
                                        <img id="profileImage" src="${current.thumbnail}" alt="Profile image of ${current.person_name}">
                                    </div>
                                    <div class="profile-text">
                                        ${representativeText}
                                    </div>
                                </div>
                            `;

                            if (new_person_country_code && new_person_country_code !== currently_displayed_map_country_code) {
                                console.log(`Current person's country (${new_person_country_code}) differs from displayed map (${currently_displayed_map_country_code}). Fetching new map.`);
                                fetch(`/generate_map_for_country/${new_person_country_code}`)
                                    .then(response => {
                                        if (!response.ok) {
                                            throw new Error(`Failed to generate map for ${new_person_country_code}: ${response.statusText}`);
                                        }
                                        return response.json();
                                    })
                                    .then(map_gen_response => {
                                        console.log(map_gen_response.status || 'Map generation triggered.');
                                        reloadHexMap();
                                        currently_displayed_map_country_code = new_person_country_code;
                                    })
                                    .catch(error => {
                                        console.error('Error updating map for new country:', error);
                                    });
                            } else {
                                // Country is the same, or no new person, but still reload map if queue changed.
                                // This ensures highlight updates if top person of same country changes.
                                reloadHexMap();
                            }
                            document.getElementById('next-button').style.display = 'block';
                        } else {
                            document.getElementById('current-constituency').innerText = 'All prayers complete or queue is empty. Stay tuned!';
                            document.getElementById('next-button').style.display = 'none';
                            // Optional: if queue is empty, maybe revert to a default map or clear it?
                            // For now, it keeps showing the last map.
                            reloadHexMap(); // Reload to ensure map is up-to-date (e.g. no highlight if queue empty)
                        }
                        // reloadHexMap(); // This was the original position, moved up for clarity
                    } else {
                        console.error('Unexpected data format:', data);
                    }
                })
                .catch(error => {
                    console.error('There has been a problem with your fetch operation:', error);
                });
        }

        function reloadHexMap() {
            const hexMap = document.getElementById('hex-map');
            const newSrc = hexMap.src.split('?')[0] + '?' + new Date().getTime();  // Force reload by adding a timestamp
            // ==== DETAILED LOGGING START ====
            console.log("Reloading hex map with new source:", newSrc);
            // ==== DETAILED LOGGING END ====
            const newImage = new Image();
            newImage.onload = function () {
                hexMap.src = newSrc;
            }
            newImage.src = newSrc;
        }

        function nextConstituency() {
            fetch('/process_item', { method: 'POST' })
                .then(() => {
                    processedCount++; // Increment local count of processed items
                    // The 'remaining' is now globally calculated in app.py and passed to the template.
                    // We should fetch the updated global remaining count, or update it based on current item processing.
                    // For simplicity, let's decrement the total displayed remaining count.
                    // A more robust solution would be to get the new 'remaining' from the server.
                    const remainingElement = document.getElementById('remaining');
                    let currentRemaining = parseInt(remainingElement.innerText);
                    if (!isNaN(currentRemaining)) {
                        remainingElement.innerText = Math.max(0, currentRemaining - 1);
                    }

                    // Fetch and log the next item from /queue/json
                    fetch('/queue/json')
                        .then(response => response.json())
                        .then(data => {
                            if (data && Array.isArray(data) && data.length > 0) {
                                console.log('Next item from queue/json after process_item:', data[0]);
                            } else if (data && Array.isArray(data) && data.length === 0) {
                                console.log('Queue is empty after process_item.');
                            } else {
                                console.log('Unexpected data format from queue/json after process_item:', data);
                            }
                            updateQueueInfo(); // Call updateQueueInfo after logging
                        })
                        .catch(error => {
                            console.error('Error fetching queue/json after processing item:', error);
                            updateQueueInfo(); // Still call updateQueueInfo to refresh UI
                        });
                })
                .catch(error => {
                    console.error('Error processing item:', error);
                    // Potentially call updateQueueInfo() here as well if the UI needs to be refreshed even on error
                });
        }

        function purgeQueue() {
            fetch('/purge', { method: 'POST' }) // Assuming GET for purge as per app.py, if POST, keep as is.
                                                // The instruction for app.py had /purge as GET.
                .then(response => {
                    if(response.ok) {
                        // Update UI after successful purge
                        processedCount = 0;
                        document.getElementById('remaining').innerText = totalRepresentativesAllCountries; // Reset to total
                        updateQueueInfo(); // This will refresh the queue display (should be empty)
                                           // and current-constituency message.
                    } else {
                        console.error('Purge request failed');
                    }
                })
                .catch(error => {
                    console.error('Error purging queue:', error);
                });
        }

        setInterval(updateQueueInfo, 10000);  // Update every 10 seconds
        updateQueueInfo();  // Initial call to populate the data immediately
    </script>
</body>
</html>
